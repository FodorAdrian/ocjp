Exam watch
===============================================================================

-------------------------------------------------------------------------------
WSKAZÓWKI DO EGZAMINU
-------------------------------------------------------------------------------

I) Wielu doświadczonych egzaminowanych nie wraca do pytań, na które udzielili 
   odpowiedź. Rób tak tylko w przypadku, gdy czujesz, że źle zrozumiałeś 
   pytanie, lub gdy źle je zinterpretowałeś za pierwszym razem. Nerwowość może
   prowadzić do pogorszenia odpowiedzi.
   
II) Widząc w zadaniu kod, którego numery linii zaczynają się od 1, masz do 
   czynienia z pełnym kodem źródłowym. Jeśli numery linii zaczynają się dalej
   niż od 1, załóż, że początek kodu, którego nie widać, jest poprawny (np.
   importy się zgadzają).
   
IV) Jeśli utkniesz na pytaniu wielokrotnego wyboru, użyj kartki/tablicy, aby
   spisać 2-3 najmocniejsze odpowiedzi i podkreśl tę, która wydaje się 
   najbardziej poprawna. Po pierwszym przebiegu testu taka notatka może 
   wyglądać np. tak:
   	21._B_ lub C 
   	33. A lub _C_
   	
   Jest to przydatne, gdy oznaczasz zadania i kontynuujesz. Możesz później
   wrócić do takiego zadania i od razu kontunuować proces myślowy, który
   porzuciłeś przy tym pytaniu. Technika ta pozwala na kontynuowanie zadania
   bez zbędnego przypominania sobie szczegółów zadania/procesu myślowego.
   Kartka papieru przyda się także przy wizualizacji zadań opisanych tekstem,
   aby je lepiej zrozumieć.      	
   	
V) Nie ma kar za złe odpowiedzi, zawsze warto zaznaczyć coś niż nic.

VI) Dobra strategia na rozwiązywanie testu:
 
	1. Przejdź szybko przez wszystkie zadania i odpowiedz na pytania,
	   co do których masz pewność i odpowiedź szybko przychodzi do głowy.
	   Czytaj pobieżnie treści zadań, rozpoznając typ i przedmiot zadania.

	   Jeśli nie jesteś przekonany co do odpowiedzi, zaznacz tą, która
	   na pierwszy rzut oka jest dobra i oznacz (Mark) pytanie do 
	   przejrzenia na potem.	   
	   
   	   Spróbuj spędzić na ten cykl mniej niż 25% czasu testu.
	   
	2. Przejdź przez wszystkie zadania jeszcze raz. Z poprzedniej fazy
	   wiesz już, na ile skomplikowany jest test i ile mniej więcej
	   czasu potrzebujesz średnio na każde zadanie. Spróbuj ustalić
	   kamienie milowe, np. "muszę rozwiązań 10 pytań co każde 15 minut".
	   W tej fazie lepiej omijać czasochłonne pytania i oznaczać je
	   na później.
	   	   
   	   Spróbuj skończyć ten cykl w momencie 50-60% czasu testu.
	
	3. W trzeciej fazie wróć do pytań, które oznaczyłeś do przejrzenia.
	   Faza ta obejmuje ponowny wgląd na zadania, co do których nie miałeś
	   pewności w dwóch poprzednich fazach i rozwiązywanie zadań 
	   czasochłnnych. Ciocaj je, do póki nie zrobisz wszystkich.
	   
	   Na koniec tego etapu powinieneś mieć odpowiedzi na wszystkie
	   pytania. Jeśli w kolejnej fazie zabraknie ci czasu, przynajmniej
	   na każde pytanie masz jakąś odpowiedź. 
	   
	   Dobrze, jeśli kończąc ten etap, zostanie ci jeszcze 10-20% czasu 
	   testu. 
	   
	4. Ostatni etap, gdy zrobisz wszystkie zadania - sprawdzenie 
	   odpowiedzi. Zrób jeszcze jeden przebieg przez wszystkie pytania,
	   pobieżnie analizując pytanie i udzieloną odpowiedź. Ostrożnie
	   analizuj zadania, aby sprawdzić, czy nie ma jakiegoś haczyka.
	   Szczególnie uważaj na pytanie, których jedną z odpowiedzi jest
	   "Błąd kompilacji". Możesz jeszcze odnaleźć ukryte błędy w zadaniu,
	   to jest twoja ostatnia szansa na poprawienie odpowiedzi.
	   
    Korzyścią z takiego podejścia jest to, że nawet pobieżne rozwiązywanie 
    zadań odświeża pamięć i może pomóc w rozwiązaniu zadań, które wcześniej 
    opuściliśmy.

VII) Ostrożnie analizuj kod źródłowy. Jeśli jedną z odpowiedzi jest "Błąd 
    kompilacji", najpierw dokładnie sprawdź składnię kodu, czy nie brakuje
    nawiasów okrądłych, średników, nawiasów wąsiastych (otwierających
    i zamykających w poprawnej kolejności), zwracaj uwagę na wielkość liter.
    
    Dopiero gdy kod się kompiluje, szukaj ewentualnych wyjątków, o ile jedną
    z odpowiedzi jest "Wyrzucenie wyjątku".
    
    Gdy upewnisz się, że nie ma błędu kompilacji ani nie są wyrzucane wyjątki,
    wtedy dopiero analizuj dogłębnie logikę kodu, np. przebiegi pętli i wartości
    zmiennych.
    
VIII) Przed egzaminem sprawdź, czy ośrodek certyfikujący należycie wyposaży cię
    w potrzebne akcesoria: kartki i długopis albo odpowiednio duża tablica
    i ścieralne mazaki.
   	
-------------------------------------------------------------------------------
TABLICE I ARRAYLIST
-------------------------------------------------------------------------------

1) Uważaj na liczbę obiektów przy konstrukcji tablic - 
   instrukcja:
		Object[] x = new Object[5];
   tworzy jeden obiekt na stosie - jest to obiekt tablicy, której elementy
   inicjalizowane są wartościami null
   
2) Widząc określenia takie jak "skonstruuj" ("construct"), "utwórz"
   ("create"), "stwórz instancję" ("instantiate") wiedz, że oznaczają one
   "obiekt tworzony jest na STERCIE". Stąd wiadomo, że konstruktor
   obiektu jest uruchamiany (i konstruktory nadklas).
   
3) Zwracaj uwagę na kod, który próbuje użyć niedozwolonego indeksu 
   tablicy. Indeks ujemny lub przekraczający indeks ostatniego
   elementu jest niedozwolony i spowoduje wyrzucenie wyjątku
   w czasie wykonania ArrayIndexOutOfBoundsException.
   
4) Pamiętaj, że nie wolno specyfikować rozmiaru tablicy przy stosowaniu
   składni tworzenia tablic anonimowych. Rozmiar jest dedukowany z liczby
   elementów rozdzielonych przecinkiem. Następujący kod jest błędny:
		int[] x = new int[2]{1, 2};  // ŹLE!
   Powinno być:	
		int[] x = new int[]{1, 2};  // OK
		
5) Pamiętaj, że przypisując tablicę obiektów zmiennej referencyjnej,
   możesz przypisać tablicę o typie tej zmiennej lub tablicę obiektów
   podtypu tej zmiennej, ale nie na odwrót. Przykład:
   class A{}
   class B extends A{}
   ...
   A[] a;
   B[] b;
   a = new B[5]; // OK
   b = new A[5]; // ŹLE!
		
6) ArrayList przechowuje referencje do obiektów. Jeśli zauważysz
   instrukcje w rodzaju: myArrayList.add(5), w rzeczywistości
   liczba 5 jest opakowywana (autoboxing) w typ Integer i obiekt
   tej klasy jest przekazywany do metody add.
   
-------------------------------------------------------------------------------
INSTRUKCJE STERUJĄCE
-------------------------------------------------------------------------------

7) Uważaj na instrukcję przypisania w wyrażeniu warunkowym instrukcji if,
   np.
		boolean boo = false;
		if (boo = true) {
			...
		}
   albo:
		if (boo =! false) {
			...
		}
   W pierwszym przypadku warunek będzie zawsze prawdziwy, bo wyrażenie
   przyjmie wartość zmiennej boo, której przypisujemy wartość true.
   NIE jest to instrukcja sprawdzająca!
   Drugi przypadek może do złudzenia przypominać operator "rożne od" -
   !=, ale w rzeczywistości jest to przypisanie !false, czyli true -
   więc warunek zawsze będzie prawdziwy.
   Pamiętaj też, że liczby całkowite nie mogą być wyrażeniem 
   warunkowym, więc poniższe instrukcje są błędne:
		int x = 1;			// ŹLE
		if (x) ...			// ŹLE
		if (x = 1) ...		// ŹLE
		if (
	
8) Uważaj na naruszenia składni instrukcji switch-case:
	switch(x) {
		case 0 {		// ŹLE - brak dwukropka po "case 0"
			y = 7;
		}
	}
	switch (x) {
		0: {}			// ŹLE - brak słowa kluczowego "case"
		1: {}
	}
	
9) Pamiętaj, że "default" w instrukcji switch może znaleźć się 
   w dowolnym miejscu między etykietami "case", wcale nie musi być
   na końcu! Np.:
	switch(x) {
		case 0: {}
		default: {}
		case 1: {}
	}
   Po prostu pamiętaj, że default rządzi się takimi samymi regułami jak
   etykiety case, z tym, że nie jest powiązane ze stałą.
   
10) Podobnie jak przy instrukcji if, uważaj na wyrażenia warunkowe w pętlach,
   np.:
	int x = 1;
	while (x) {}  		// ŹLE
	while (x = 1) {} 	// ŹLE
	while (x == 1) {}	// OK
	while (true) {}		// OK
	while (false) {}	// ŹLE: error: unreachable statement

11) Uważaj na zakres zmiennych lokalnych. Ma to duże znaczenie na egzaminie.
    Pamiętaj, że zmienna zadeklarowana w kroku inicjalizacji pętli for nie
    jest widoczna poza blokiem pętli for, ale możesz użyć zmiennej zdefinio-
    wanej wcześniej:
	int x = 3;
	for (x = 0; x < 20; x++) {}
	System.out.println(x);			// OK
	for (int i = 0; i < 0; i++) {}
	System.out.println(i);			// ŹLE - zmienna i już nie istnieje
	
12) Wiele pytać na egzaminie ma w liście odpowiedzi "Compilation fails" albo
    "An exception occurs on runtime". Dokładnie sprawdź najpierw, czy kod
    się skompiluje, następnie czy nie wystąpi wyjątek w czasie wykonania.
    Dopiero wtedy analizuj logikę kodu.
	
13) Pamiętaj, że instrukcja continue musi być w środku PĘTLI, inaczej
    dostaniesz błąd kompilacji. Instrukcja break może być użyta w pętli
    lub w instrukcji switch.
    Brak i continue z etykietami muszą znajdować się w pętli, która oznaczona
    jest taką samą etykietą.

-------------------------------------------------------------------------------
WYJĄTKI
-------------------------------------------------------------------------------

14) Nie wolno używać klauzuli try jednocześnie bez klauzul catch i finally. 
    Sama klauzula try spowoduje błąd kompilacji. Każda klauzula catch musi 
    znajdować się bezpośrednio po bloku try. Klauzula finally musi znajdować
    się bezpośrednio po ostatnim bloku catch (lub po bloku try, jeśli nie ma żadnej
    klauzuli catch). Można pominąć klauzulę catch albo finally, ale nie obie naraz.
    
15) Możesz propagować wyjątek w dół stosu wywołań metod. A co jeżeli wyjątek 
    dojdzie do metody main()? Możesz wyrzucić wyjątek również z metody main().
    Powoduje to zatrzymanie JVM i wypisanie stack-trace'u na wyjściu.
    
16) Do egzaminu nie musisz znać żadnej metody w klasie Throwable, włączając do 
    tego Exception i Error. Musisz natomiast wiedzieć to, że każdy z typów
    Exception, RuntimeException, Error i Throwable może być wyrzucony z użyciem
    klauzuli throw i może być złapany (chociaż żadko będzie łapał cokolwiek 
    innego niż podtyp klasy Exception).
    
17) Zwróć uwagę na poniższy kod, w którym metoda wołająca nie obsługuje ani nie
    deklaruje wyrzuconego wyjątku sprawdzanego:
    
	void doStuff() { doMore(); }
	void doMore() { throw new IOException(); }  // ŹLE
	 
    Metoda doMore() wyrzuca sprawdzany wyjątek, którego nie deklaruje! Taki kod
    się nie skompiluje. Ale jeśli dodamy deklarację do metody doMore:
    
	void doMore() throws IOException { throw new IOException(); }  // OK

    W dalszym ciągu metoda doStuff jest niepoprawna, ponieważ nie łapie ani
    nie deklaruje wyjątku. Możemy zatem albo propagować wyjątek w dół stosu 
    wywołań:
    	
	void doStuff() throws IOException { doMore(); }
    	 
    albo obsłużyć wyjątek, np. tak:
    
	void doStuff() { 
		try {
			doMore();
		} catch(IOException e) {
			e.printStackTrace();	
		}
	}
	
18) Kiedy obiekt podtypu Exception jest wyrzucany (z typem Exception włącznie), 
    musi zostać obsłużony albo zadeklarowany. Takie wyjątki są nazywane wyjątkami
    sprawdzanymi i zawierają wszystkie wyjątki oprócz podklas RuntimeException
    (z klasą RuntimeException włącznie), które z kolei są niesprawdzane.
    
    Bądź gotowy na kod, w którym reguła "obsłuż albo zadeklaruj" nie jest 
    spełniona, np.:
	
	class MyException extends Exception {
		void someMethod() { 
			doStuff(); 
		}		
		void doStuff() throws MyException {
			try {
				throw new MyException();
			} catch (MyException me) {
				throw me;
			}
		}
	}
	
    Musisz umieć rozpoznać tutaj błąd kompilacji: metoda someMethod() nie 
    obsługuje ani nie deklaruje wyjątku MyException, który jest sprawdzany.
 
-------------------------------------------------------------------------------
STRING i STRINGBUILDER
-------------------------------------------------------------------------------

19) Pamiętaj, że klasa String ma metodę length(), która podaje liczbę znaków
    (długość stringa), natomiast tablice obiektów mają stałą length, która
    określa ilość elementów w tablicy. Uważaj więc na poniższy kod:
    
    String x = "test";
    // int N = x.length;	// BŁĄD
    int N = x.length();		// OK
    
    String[] xA = {"test"};
    // int N = xA.length();	// BŁĄD
    int N = xA.length;		// OK

20) Obiekty StringBuilder mają swoją pojemność - capacity, która określa ile
    znaków może pomieścić się w obiekcie.
    Są trzy sposoby na utworzenie obiektu StringBuilder:
    
	1) new StringBuilder();		// domyśle capacity = 16 znaków
	2) new StringBuilder("ab");	// capacity = 16 znaków + "ab".length = 18
	3) new StringBuilder(x);	// capacity = x znaków (int)
	
    Najczęściej przy pracy ze StringBuilderem używa się metod append()
    i insert(). Są trzy reguły do zapamiętania przy pracy ze StringBuilderem:
    
    	*) jeśli po użyciu instrukcji append() napis przekroczy pojemność,
    	   zostanie ona automatycznie zwiększona
    	*) jeśli insert() wstawia napis o indeksie mieszczącym się w pojemności,
    	   ale napis ostateczny przekracza pojemność obiektu, zostanie ona
    	   zwiększona automatycznie
    	*) jeśli insert() próbuje wstawić napis o indeksie przekraczającym
    	   bieżącą długość napisu w obiekcie, zostanie wyrzucony wyjątek
    	   StringIndexOutOfBoundsException.

21) Na egzaminie będziesz sprawdzany z wiedzy nt. różnic między obiektami 
    klasy String i StringBuilder. Ponieważ obiekty StringBuilder można
    zmieniać, tj. w odróżnieniu do obiektów String są mutowalne, poniższy
    kod zadziała inaczej niż analogiczny dla klasy String:
    
	StringBuilder sb = new StringBuilder("abc");
	sb.append("def");
	System.out.println(sb); // wypisze "abcdef"
	
22) Sporo zadań na egzaminie używa składni zwanej "łancuchem metod". 
    Przykład:

	result = method1().method2().method3();
	
    Teoretycznie, dowolna ilość metod może być wywołana tym sposobem,
    chociaż w praktyce raczej nie zobaczysz więcej niż trzy wywołania.
    Oto jak należy rozszyfrować tę notację:
    
    	1. Określ, co zwraca wywołanie pierwsze z lewej (nazwijmy 
    	   tę wartość "x").
    	2. Użyj "x" jako obiektu, na którym wykonasz drugie z lewej 
    	   wywołanie metody. Jeśli są tylko dwa wywołania, rezultat
    	   drugiego stanie się wartością wyrażenia (result).
    	3. Jeśli jest trzecie wywołanie metody, rezultat drugiego
    	   wywołania użyj jako obiekt, na którym wykonasz trzecie
    	   wywołanie. Rezultat trzeciego wywołania staje się wartością
    	   wyrażenia, itd.

-------------------------------------------------------------------------------
DEFINIOWANIE KLAS
-------------------------------------------------------------------------------

23) Możesz używać znaku gwiazdki '*' (wildcard), aby zrealizować proste 
    wyszukiwanie w pakietach lub klasach używając instrukcji 'import' lub
    'import static'. Jeśli chcesz przeszukać pakiet java.util w poszukiwaniu
    klas, możesz napisać:`
    
    Ale nie możesz przeszukiwać szerzej. np. NIE MOŻESZ użyć instrukcji import
    aby przeszukać całe Java API np. w następujący sposób:
    
	import java.*;	// ŹLE - skompiluje się, ale nie zadziała w oczekiwany
	                // sposób!

-------------------------------------------------------------------------------
UŻYWANIE INTERFEJSÓW
-------------------------------------------------------------------------------

24) Uważaj na stałe zdefiniowane w interfejsie. Każda deklaracja zmiennej
    w interfejsie to w rzeczywistości zdefiniowanie stałej, ponieważ w mocy są
    modyfikatory public, static i final domyślne dla każdej zmiennej 
    w interfejsie. Poniższe definicje są równoważne:
    
	int x = 1;
	public int x = 1;
	static int x = 1;
	final int x = 1;
	public static int x = 1;
	public final int x = 1;
	static final int x = 1;
	public static final int x = 1;  // ostateczna, domyślna wersja

-------------------------------------------------------------------------------
DEKLAROWANIE CZŁONKÓW KLAS
-------------------------------------------------------------------------------

25) Nie wolno nigdy umieszczać wielkości tablicy w jej deklaracji! Np. taki
    kod jest błędny:
    
	int[5] scores;	// BŁĄD!
	
    Nastąpi błąd kompilacji. Rozmiar jest bowiem ustalany dopiero przy 
    tworzeniu instancji tablicy.
